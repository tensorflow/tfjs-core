import { Tensor } from '../tensor';
import { TensorLike } from '../types';
export declare class UnaryOps {
    static neg<T extends Tensor>(x: T | TensorLike): T;
    static ceil<T extends Tensor>(x: T | TensorLike): T;
    static floor<T extends Tensor>(x: T | TensorLike): T;
    static sign<T extends Tensor>(x: T | TensorLike): T;
    static round<T extends Tensor>(x: T | TensorLike): T;
    static exp<T extends Tensor>(x: T | TensorLike): T;
    static expm1<T extends Tensor>(x: T | TensorLike): T;
    static log<T extends Tensor>(x: T | TensorLike): T;
    static log1p<T extends Tensor>(x: T | TensorLike): T;
    static sqrt<T extends Tensor>(x: T | TensorLike): T;
    static rsqrt<T extends Tensor>(x: T | TensorLike): T;
    static square<T extends Tensor>(x: T | TensorLike): T;
    static reciprocal<T extends Tensor>(x: T | TensorLike): T;
    static abs<T extends Tensor>(x: T | TensorLike): T;
    static clipByValue<T extends Tensor>(x: T | TensorLike, clipValueMin: number, clipValueMax: number): T;
    static relu<T extends Tensor>(x: T | TensorLike): T;
    static elu<T extends Tensor>(x: T | TensorLike): T;
    static selu<T extends Tensor>(x: T | TensorLike): T;
    static leakyRelu<T extends Tensor>(x: T | TensorLike, alpha?: number): T;
    static prelu<T extends Tensor>(x: T | TensorLike, alpha: T | TensorLike): T;
    static sigmoid<T extends Tensor>(x: T | TensorLike): T;
    static logSigmoid<T extends Tensor>(x: T | TensorLike): T;
    static softplus<T extends Tensor>(x: T | TensorLike): T;
    static sin<T extends Tensor>(x: T | TensorLike): T;
    static cos<T extends Tensor>(x: T | TensorLike): T;
    static tan<T extends Tensor>(x: T | TensorLike): T;
    static asin<T extends Tensor>(x: T | TensorLike): T;
    static acos<T extends Tensor>(x: T | TensorLike): T;
    static atan<T extends Tensor>(x: T | TensorLike): T;
    static sinh<T extends Tensor>(x: T | TensorLike): T;
    static cosh<T extends Tensor>(x: T | TensorLike): T;
    static tanh<T extends Tensor>(x: T | TensorLike): T;
    static asinh<T extends Tensor>(x: T | TensorLike): T;
    static acosh<T extends Tensor>(x: T | TensorLike): T;
    static atanh<T extends Tensor>(x: T | TensorLike): T;
    static erf<T extends Tensor>(x: T | TensorLike): T;
    static step<T extends Tensor>(x: T | TensorLike, alpha?: number): T;
}
