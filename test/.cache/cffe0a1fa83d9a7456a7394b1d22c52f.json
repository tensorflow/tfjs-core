{"dependencies":[{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16real/tfjs-core/test/package.json","includedInParent":true,"mtime":1524156395000},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16real/tfjs-core/test/.babelrc","includedInParent":true,"mtime":1524156663000},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16real/tfjs-core/tsconfig.json","includedInParent":true,"mtime":1524152197486},{"name":"../util","loc":{"line":3,"column":19}}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util = require(\"../util\");\nfunction assertParams(aShape, bShape, axis) {\n    var aRank = aShape.length;\n    var bRank = bShape.length;\n    util.assert(aShape.length === bShape.length, \"Error in concat\" + aRank + \"D: rank of x1 (\" + aRank + \") and x2 (\" + bRank + \") \" +\n        \"must be the same.\");\n    util.assert(axis >= 0 && axis < aRank, \"Error in concat\" + aRank + \"D: axis must be \" +\n        (\"between 0 and \" + (aRank - 1) + \".\"));\n    for (var i = 0; i < aRank; i++) {\n        util.assert((i === axis) || (aShape[i] === bShape[i]), \"Error in concat\" + aRank + \"D: Shape (\" + aShape + \") does not match \" +\n            (\"(\" + bShape + \") along the non-concatenated axis \" + i + \".\"));\n    }\n}\nexports.assertParams = assertParams;\nfunction computeOutShape1D(x1Shape, x2Shape) {\n    util.assert(x1Shape.length === 1 && x2Shape.length === 1, 'x1 and x2 should be 1d array.');\n    var outputShape = x1Shape.slice();\n    outputShape[0] += x2Shape[0];\n    return outputShape;\n}\nexports.computeOutShape1D = computeOutShape1D;\nfunction computeOutShape(x1Shape, x2Shape, axis) {\n    util.assert(x1Shape.length === x2Shape.length, 'x1 and x2 should have the same rank.');\n    var outputShape = x1Shape.slice();\n    outputShape[axis] += x2Shape[axis];\n    return outputShape;\n}\nexports.computeOutShape = computeOutShape;\nfunction computeGradientSliceShapes(aShape, bShape) {\n    return {\n        aBegin: [0, 0],\n        aSize: aShape,\n        bBegin: [0, aShape[1]],\n        bSize: bShape\n    };\n}\nexports.computeGradientSliceShapes = computeGradientSliceShapes;\n"},"hash":"36a37ca326950437a302cab1dc5bad5c","cacheData":{"env":{}}}