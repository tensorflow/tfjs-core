<style>
.heading {

}
.subheading {

}
.method {

}
.parameter {

}
</style>

API Reference


  <div class="heading">
    <h1>Tensors</h1>
      <div class="subheading">
        <h2>Creation</h2>
          <div class="method">
            <h3>ones</h3>
            <div class="docstring">Creates a ndarray of ones with the specified shape. </div>
            <ul>
                <li class="parameter">
                  shape ShapeMap[R] 
                </li>
                <li class="parameter">
                  dtype &quot;float32&quot; | &quot;int32&quot; | &quot;bool&quot; 
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>zeros</h3>
            <div class="docstring">Creates a ndarray of zeros with the specified shape. </div>
            <ul>
                <li class="parameter">
                  shape ShapeMap[R] 
                </li>
                <li class="parameter">
                  dtype &quot;float32&quot; | &quot;int32&quot; | &quot;bool&quot; 
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>onesLike</h3>
            <div class="docstring">Creates a ndarray of ones with the same shape as the specified ndarray.</div>
            <ul>
                <li class="parameter">
                  x T 
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>zerosLike</h3>
            <div class="docstring">Creates a ndarray of zeros with the same shape as the specified ndarray.</div>
            <ul>
                <li class="parameter">
                  x T 
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>clone</h3>
            <div class="docstring">Creates a ndarray with the same values&#x2F;shape as the specified ndarray. </div>
            <ul>
                <li class="parameter">
                  x T 
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>randNormal</h3>
            <div class="docstring"></div>
            <ul>
                <li class="parameter">
                  shape ShapeMap[R] 
                </li>
                <li class="parameter">
                  mean number 
                </li>
                <li class="parameter">
                  stdDev number 
                </li>
                <li class="parameter">
                  dtype &quot;float32&quot; | &quot;int32&quot; 
                </li>
                <li class="parameter">
                  seed number 
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>truncatedNormal</h3>
            <div class="docstring"></div>
            <ul>
                <li class="parameter">
                  shape ShapeMap[R] 
                </li>
                <li class="parameter">
                  mean number 
                </li>
                <li class="parameter">
                  stdDev number 
                </li>
                <li class="parameter">
                  dtype &quot;float32&quot; | &quot;int32&quot; 
                </li>
                <li class="parameter">
                  seed number 
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>randUniform</h3>
            <div class="docstring"></div>
            <ul>
                <li class="parameter">
                  shape ShapeMap[R] 
                </li>
                <li class="parameter">
                  a number 
                </li>
                <li class="parameter">
                  b number 
                </li>
                <li class="parameter">
                  dtype &quot;float32&quot; | &quot;int32&quot; | &quot;bool&quot; 
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>rand</h3>
            <div class="docstring"></div>
            <ul>
                <li class="parameter">
                  shape ShapeMap[R] 
                </li>
                <li class="parameter">
                  randFunction () &#x3D;&gt; number 
                </li>
                <li class="parameter">
                  dtype &quot;float32&quot; | &quot;int32&quot; | &quot;bool&quot; 
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>multinomial</h3>
            <div class="docstring">Draws samples from a multinomial distribution.</div>
            <ul>
                <li class="parameter">
                  probabilities Array1D | Array2D 1D array with normalized outcome probabilities, or
2D array of shape &#x60;[batchSize, numOutcomes]&#x60;.
                </li>
                <li class="parameter">
                  numSamples number Number of samples to draw for each row slice.
                </li>
                <li class="parameter">
                  seed number Optional. The seed number.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>oneHot</h3>
            <div class="docstring">Returns a one-hot array. The locations represented by &#x60;indices&#x60; take
value &#x60;onValue&#x60; (defaults to 1), while all other locations take value
&#x60;offValue&#x60; (defaults to 0).</div>
            <ul>
                <li class="parameter">
                  indices Array1D 1D Array of indices.
                </li>
                <li class="parameter">
                  depth number The depth of the one hot dimension.
                </li>
                <li class="parameter">
                  onValue number A number used to fill in output when the index matches the
location.
                </li>
                <li class="parameter">
                  offValue number A number used to fill in the output when the index does
not match the location.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>fromPixels</h3>
            <div class="docstring"></div>
            <ul>
                <li class="parameter">
                  pixels any 
                </li>
                <li class="parameter">
                  numChannels number 
                </li>
            </ul>
          </div>
      </div>
      <div class="subheading">
        <h2>Transformations</h2>
          <div class="method">
            <h3>reshape</h3>
            <div class="docstring">Reshapes the array. </div>
            <ul>
                <li class="parameter">
                  x NDArray&lt;Rank&gt; 
                </li>
                <li class="parameter">
                  newShape ShapeMap[R2] 
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>cast</h3>
            <div class="docstring">Casts a tensor to a new type. If the new type matches the old type,
this is a no-op.</div>
            <ul>
                <li class="parameter">
                  x T 
                </li>
                <li class="parameter">
                  newDType &quot;float32&quot; | &quot;int32&quot; | &quot;bool&quot; 
                </li>
            </ul>
          </div>
      </div>
      <div class="subheading">
        <h2>Slicing and Joining</h2>
          <div class="method">
            <h3>tile</h3>
            <div class="docstring">Construct an array by repeating it the number of times given by reps.

This operation creates a new array by replicating &#x60;input&#x60; &#x60;reps&#x60;
times. The output tensor&#39;s i&#39;th dimension has &#x60;input.shape[i] *
reps[i]&#x60; elements, and the values of &#x60;input&#x60; are replicated
&#x60;reps[i]&#x60; times along the i&#39;th dimension. For example, tiling
&#x60;[a, b, c, d]&#x60; by &#x60;[2]&#x60; produces &#x60;[a, b, c, d, a, b, c, d]&#x60;.</div>
            <ul>
                <li class="parameter">
                  x T The array to transpose.
                </li>
                <li class="parameter">
                  reps {} Determines the number of replications per dimension.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>gather</h3>
            <div class="docstring">Gather slices from array &#x60;x&#x60;&#39;s axis &#x60;axis&#x60; according to &#x60;indices&#x60;</div>
            <ul>
                <li class="parameter">
                  x T The array to transpose.
                </li>
                <li class="parameter">
                  indices Array1D The indices of the values to extract.
                </li>
                <li class="parameter">
                  axis number Optional. The axis over which to select values. Defaults to 0.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>pad1D</h3>
            <div class="docstring">Pads a Array1D.

This operation will pad an array according to the &#x60;paddings&#x60; you specify.

This operation currently only implements the &#x60;CONSTANT&#x60; mode from
Tensorflow&#39;s &#x60;pad&#x60; operation.</div>
            <ul>
                <li class="parameter">
                  x Array1D The array to pad.
                </li>
                <li class="parameter">
                  paddings [number, number] A tuple of ints [padLeft, padRight], how much to pad on the
left and right side of the array.
                </li>
                <li class="parameter">
                  constantValue number The scalar pad value to use. Defaults to 0.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>pad2D</h3>
            <div class="docstring">Pads a Array2D.

This operation will pad an array according to the &#x60;paddings&#x60; you specify.

This operation currently only implements the &#x60;CONSTANT&#x60; mode from
Tensorflow&#39;s &#x60;pad&#x60; operation.</div>
            <ul>
                <li class="parameter">
                  x Array2D The array to pad.
                </li>
                <li class="parameter">
                  paddings [[number, number], [number, number]] A pair of tuple ints
[[padTop, padBottom], [padLeft, padRight]], how much to pad on the
array.
                </li>
                <li class="parameter">
                  constantValue number The scalar pad value to use. Defaults to 0.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>concat1D</h3>
            <div class="docstring">Concatenates two 1D arrays.

For example, if:
A: shape(3) &#x3D; |r1, g1, b1|
B: shape(2) &#x3D; |r2, g2|
C &#x3D; concat1D(A, B) &#x3D;&#x3D; |r1, g1, b1, r2, g2|</div>
            <ul>
                <li class="parameter">
                  a Array1D The first array.
                </li>
                <li class="parameter">
                  b Array1D The second array.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>concat2D</h3>
            <div class="docstring">Concatenates two 2D arrays along a given axis.

For example, if:
A: shape(2, 3) &#x3D; | r1, g1, b1 |
                  | r2, g2, b2 |

B: shape(2, 3) &#x3D; | r3, g3, b3 |
                  | r4, g4, b4 |

C &#x3D; concat2D(A, B, axis)

if axis &#x3D; 0:
C: shape(4, 3) &#x3D; | r1, g1, b1 |
                  | r2, g2, b2 |
                  | r3, g3, b3 |
                  | r4, g4, b4 |

if axis &#x3D; 1:
C &#x3D; shape(2, 6) &#x3D; | r1, g1, b1, r3, g3, b3 |
                   | r2, g2, b2, r4, g4, b4 |</div>
            <ul>
                <li class="parameter">
                  a Array2D The first array.
                </li>
                <li class="parameter">
                  b Array2D The second array.
                </li>
                <li class="parameter">
                  axis number The axis to concatenate along.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>concat3D</h3>
            <div class="docstring">Concatenates two 3D ndarrays along a given axis.

For example, if:
A: shape(2, 1, 3) &#x3D; | r1, g1, b1 |
                     | r2, g2, b2 |

B: shape(2, 1, 3) &#x3D; | r3, g3, b3 |
                     | r4, g4, b4 |

C &#x3D; concat3D(A, B, axis)

if axis &#x3D; 0:
C: shape(4, 1, 3) &#x3D; | r1, g1, b1 |
                     | r2, g2, b2 |
                     | r3, g3, b3 |
                     | r4, g4, b4 |

if axis &#x3D; 1:
C: shape(2, 2, 3) &#x3D; | r1, g1, b1, r3, g3, b3 |
                     | r2, g2, b2, r4, g4, b4 |

if axis &#x3D; 2:
C &#x3D; shape(2, 1, 6) &#x3D; | r1, g1, b1, r3, g3, b3 |
                      | r2, g2, b2, r4, g4, b4 |</div>
            <ul>
                <li class="parameter">
                  a Array3D The first array to concat.
                </li>
                <li class="parameter">
                  b Array3D The second array to conat.
                </li>
                <li class="parameter">
                  axis number The axis to concate along.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>concat4D</h3>
            <div class="docstring">Concatenates two 4D ndarrays along a given axis. See math.concat2D() for
documentation.</div>
            <ul>
                <li class="parameter">
                  a Array4D The first array to concat.
                </li>
                <li class="parameter">
                  b Array4D The second array to conat.
                </li>
                <li class="parameter">
                  axis number The axis to concate along.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>concat</h3>
            <div class="docstring"></div>
            <ul>
                <li class="parameter">
                  a T 
                </li>
                <li class="parameter">
                  b T 
                </li>
                <li class="parameter">
                  axis number 
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>reverse1D</h3>
            <div class="docstring">Reverses a 1D array</div>
            <ul>
                <li class="parameter">
                  x Array1D The input array.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>reverse2D</h3>
            <div class="docstring">Reverses a 2D array along a specified axis</div>
            <ul>
                <li class="parameter">
                  x Array2D The input array.
                </li>
                <li class="parameter">
                  axis number | {} The set of dimensions to reverse. Must be in the
range [-rank(x), rank(x)).
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>reverse3D</h3>
            <div class="docstring">Reverses a 3D array along a specified axis</div>
            <ul>
                <li class="parameter">
                  x Array3D The input array.
                </li>
                <li class="parameter">
                  axis number | {} The set of dimensions to reverse. Must be in the
range [-rank(x), rank(x)).
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>reverse4D</h3>
            <div class="docstring">Reverses a 4D array along a specified axis</div>
            <ul>
                <li class="parameter">
                  x Array4D The input array.
                </li>
                <li class="parameter">
                  axis number | {} The set of dimensions to reverse. Must be in the
range [-rank(x), rank(x)).
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>reverse</h3>
            <div class="docstring">Reverses an NDArray along a specified axis.</div>
            <ul>
                <li class="parameter">
                  x NDArray&lt;R&gt; The input array.
                </li>
                <li class="parameter">
                  axis number | {} The set of dimensions to reverse. Must be in the
range [-rank(x), rank(x)).
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>slice1D</h3>
            <div class="docstring">Extracts a 1D slice from 1D array starting at coordinates &#x60;begin&#x60; and is
of length &#x60;size&#x60;.</div>
            <ul>
                <li class="parameter">
                  x Array1D The input array to slice from.
                </li>
                <li class="parameter">
                  begin number The offset to start the slice from.
                </li>
                <li class="parameter">
                  size number The size of the slice.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>slice2D</h3>
            <div class="docstring">Extracts a 2D slice from a 2D array starting at coordinates &#x60;begin&#x60; and
is of size &#x60;size&#x60;.</div>
            <ul>
                <li class="parameter">
                  x Array2D The input array to slice from.
                </li>
                <li class="parameter">
                  begin [number, number] The [row, col] 2d coordinates to start the slice from.
                </li>
                <li class="parameter">
                  size [number, number] The size of the slice.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>slice3D</h3>
            <div class="docstring">Extracts a 3D slice from a 3D array starting at coordinates &#x60;begin&#x60; and
is of size &#x60;size&#x60;.</div>
            <ul>
                <li class="parameter">
                  x Array3D The input array to slice from.
                </li>
                <li class="parameter">
                  begin [number, number, number] The [row, col, depth] 3d coordinates to start the slice from.
                </li>
                <li class="parameter">
                  size [number, number, number] The size of the slice.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>slice4D</h3>
            <div class="docstring">Extracts a 4D slice from a 4D array starting at coordinates &#x60;begin&#x60; and
is of size &#x60;size&#x60;.</div>
            <ul>
                <li class="parameter">
                  x Array4D The input array to slice from.
                </li>
                <li class="parameter">
                  begin [number, number, number, number] The [row, col, depth, depth2] 4d coordinates to start the
slice from.
                </li>
                <li class="parameter">
                  size [number, number, number, number] The size of the slice.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>slice</h3>
            <div class="docstring"></div>
            <ul>
                <li class="parameter">
                  x NDArray&lt;R&gt; 
                </li>
                <li class="parameter">
                  begin ShapeMap[R] 
                </li>
                <li class="parameter">
                  size ShapeMap[R] 
                </li>
            </ul>
          </div>
      </div>
  </div>
  <div class="heading">
    <h1>Operations</h1>
      <div class="subheading">
        <h2>Normalization</h2>
          <div class="method">
            <h3>batchNormalization2D</h3>
            <div class="docstring">Batch normalization 2D. Mean, variance, scale, and offset can be of two
shapes: 1) The same shape as the input: an Array2D. 2) In the common
case, the depth dimension is the last dimension of x, so the values would
be an Array1D of shape [depth].</div>
            <ul>
                <li class="parameter">
                  x Array2D The input NDArray.
                </li>
                <li class="parameter">
                  mean Array1D | Array2D A mean NDArray.
                </li>
                <li class="parameter">
                  variance Array1D | Array2D A variance NDArray.
                </li>
                <li class="parameter">
                  varianceEpsilon number A small float number to avoid dividing by 0.
                </li>
                <li class="parameter">
                  scale Array1D | Array2D A scale NDArray.
                </li>
                <li class="parameter">
                  offset Array1D | Array2D An offset NDArray.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>batchNormalization3D</h3>
            <div class="docstring">Batch normalization 3D. Mean, variance, scale, and offset can be of two
shapes: 1) The same shape as the input: an Array3D. 2) In the common
case, the depth dimension is the last dimension of x, so the values would
be an Array1D of shape [depth].</div>
            <ul>
                <li class="parameter">
                  x Array3D The input NDArray.
                </li>
                <li class="parameter">
                  mean Array1D | Array3D A mean NDArray.
                </li>
                <li class="parameter">
                  variance Array1D | Array3D A variance NDArray.
                </li>
                <li class="parameter">
                  varianceEpsilon number A small float number to avoid dividing by 0.
                </li>
                <li class="parameter">
                  scale Array1D | Array3D A scale NDArray.
                </li>
                <li class="parameter">
                  offset Array1D | Array3D An offset NDArray.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>batchNormalization4D</h3>
            <div class="docstring">Batch normalization 4D. Mean, variance, scale, and offset can be of two
shapes: 1) The same shape as the input: an Array4D. 2) In the common
case, the depth dimension is the last dimension of x, so the values would
be an Array1D of shape [depth].</div>
            <ul>
                <li class="parameter">
                  x Array4D The input NDArray.
                </li>
                <li class="parameter">
                  mean Array1D | Array4D A mean NDArray.
                </li>
                <li class="parameter">
                  variance Array1D | Array4D A variance NDArray.
                </li>
                <li class="parameter">
                  varianceEpsilon number A small float number to avoid dividing by 0.
                </li>
                <li class="parameter">
                  scale Array1D | Array4D A scale NDArray.
                </li>
                <li class="parameter">
                  offset Array1D | Array4D An offset NDArray.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>batchNormalization</h3>
            <div class="docstring"></div>
            <ul>
                <li class="parameter">
                  x NDArray&lt;R&gt; 
                </li>
                <li class="parameter">
                  mean Array1D | NDArray&lt;R&gt; 
                </li>
                <li class="parameter">
                  variance Array1D | NDArray&lt;R&gt; 
                </li>
                <li class="parameter">
                  varianceEpsilon number 
                </li>
                <li class="parameter">
                  scale Array1D | NDArray&lt;R&gt; 
                </li>
                <li class="parameter">
                  offset Array1D | NDArray&lt;R&gt; 
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>moments</h3>
            <div class="docstring">Calculates the mean and variance of &#x60;x&#x60;. The mean and variance are
calculated by aggregating the contents of &#x60;x&#x60; across &#x60;axes&#x60;. If &#x60;x&#x60; is
1-D and &#x60;axes &#x3D; [0]&#x60; this is just the mean and variance of a vector.</div>
            <ul>
                <li class="parameter">
                  x NDArray&lt;Rank&gt; The input array.
                </li>
                <li class="parameter">
                  axis number | {} Optional. The dimension(s) along with to compute mean and
variance. By default it reduces all dimensions.
                </li>
                <li class="parameter">
                  keepDims boolean If true, the moments have the same dimensionality as the
input.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>softmax</h3>
            <div class="docstring">Computes the softmax normalized vector given the logits.</div>
            <ul>
                <li class="parameter">
                  logits T The logits array.
                </li>
                <li class="parameter">
                  dim number The dimension softmax would be performed on. Defaults to -1
which indicates the last dimension.
                </li>
            </ul>
          </div>
      </div>
      <div class="subheading">
        <h2>Arithmetic</h2>
          <div class="method">
            <h3>add</h3>
            <div class="docstring">Adds two NDArrays element-wise, A + B. Supports broadcasting.
For a stricter version without broadcasting use addStrict().</div>
            <ul>
                <li class="parameter">
                  a NDArray&lt;Rank&gt; The first &#x60;NDArray&#x60; to add.
                </li>
                <li class="parameter">
                  b NDArray&lt;Rank&gt; The second &#x60;NDArray&#x60; to add. Must have the same type as &#x60;a&#x60;.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>addStrict</h3>
            <div class="docstring">Adds two NDArrays element-wise, A + B. Inputs must
be the same shape. For broadcasting support, use add() instead.</div>
            <ul>
                <li class="parameter">
                  a T The first NDArray to multiply element-wise.
                </li>
                <li class="parameter">
                  b T The second NDArray to multiply element-wise.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>sub</h3>
            <div class="docstring">Subtracts two NDArrays element-wise, A - B. Supports broadcasting.
For a stricter version without broadcasting use subStrict().</div>
            <ul>
                <li class="parameter">
                  a NDArray&lt;Rank&gt; The first &#x60;NDArray&#x60;.
                </li>
                <li class="parameter">
                  b NDArray&lt;Rank&gt; The second &#x60;NDArray&#x60;. Must have the same dtype as &#x60;a&#x60;.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>subStrict</h3>
            <div class="docstring">Subtracts two NDArrays element-wise, A - B. Inputs must
be the same shape. For broadcasting support, use sub() instead.</div>
            <ul>
                <li class="parameter">
                  a T The first NDArray to multiply element-wise.
                </li>
                <li class="parameter">
                  b T The second NDArray to multiply element-wise.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>pow</h3>
            <div class="docstring">Computes the power of one value to another. Supports broadcasting.
Given a tensor x and a tensor y, this operation computes x^y for
corresponding elements in x and y. For example:
x &#x3D; tf.constant([[2, 2], [3, 3]])
y &#x3D; tf.constant([[8, 16], [2, 3]])
pow(x, y)  # [[256, 65536], [9, 27]]</div>
            <ul>
                <li class="parameter">
                  base NDArray&lt;Rank&gt; The base NDArray to pow element-wise.
                </li>
                <li class="parameter">
                  exp NDArray&lt;Rank&gt; The exponent NDArray to pow element-wise.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>powStrict</h3>
            <div class="docstring">Computes the power of one value to another. Inputs must
be the same shape. For broadcasting support, use pow() instead.</div>
            <ul>
                <li class="parameter">
                  base T The base NDArray to pow element-wise.
                </li>
                <li class="parameter">
                  exp NDArray&lt;Rank&gt; The exponent NDArray to pow element-wise.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>mul</h3>
            <div class="docstring">Multiplies two NDArrays element-wise, A * B. Supports broadcasting.
For a stricter version without broadcasting use mulStrict().</div>
            <ul>
                <li class="parameter">
                  a NDArray&lt;Rank&gt; The first &#x60;NDArray&#x60;.
                </li>
                <li class="parameter">
                  b NDArray&lt;Rank&gt; The second &#x60;NDArray&#x60;. Must have the same dtype as &#x60;a&#x60;.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>elementWiseMul</h3>
            <div class="docstring"></div>
            <ul>
                <li class="parameter">
                  a T 
                </li>
                <li class="parameter">
                  b T 
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>mulStrict</h3>
            <div class="docstring">Multiplies two NDArrays element-wise, A * B. Inputs must
be the same shape. For broadcasting support, use mul().</div>
            <ul>
                <li class="parameter">
                  a T The first &#x60;NDArray&#x60;.
                </li>
                <li class="parameter">
                  b T The second &#x60;NDArray&#x60;. Must have the same dtype as &#x60;a&#x60;.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>div</h3>
            <div class="docstring">Divides two NDArrays element-wise, A &#x2F; B. Supports broadcasting.
For a stricter version without broadcasting use divStrict().</div>
            <ul>
                <li class="parameter">
                  a NDArray&lt;Rank&gt; The first &#x60;NDArray&#x60;.
                </li>
                <li class="parameter">
                  b NDArray&lt;Rank&gt; The second &#x60;NDArray&#x60;. Must have the same dtype as &#x60;a&#x60;.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>divStrict</h3>
            <div class="docstring">Divides two NDArrays element-wise, A &#x2F; B. Inputs must
be the same shape. For broadcasting support, use div() instead.</div>
            <ul>
                <li class="parameter">
                  a T The first NDArray to multiply element-wise.
                </li>
                <li class="parameter">
                  b T The second NDArray to multiply element-wise.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>minimum</h3>
            <div class="docstring">Returns the min of a and b (&#x60;a &lt; b ? a : b&#x60;) element-wise.
Supports broadcasting.</div>
            <ul>
                <li class="parameter">
                  a NDArray&lt;Rank&gt; The first ndarray.
                </li>
                <li class="parameter">
                  b NDArray&lt;Rank&gt; The second ndarray. Must have the same type as &#x60;a&#x60;.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>minimumStrict</h3>
            <div class="docstring">Returns the min of a and b (&#x60;a &lt; b ? a : b&#x60;) element-wise. Inputs must
be the same shape. For broadcasting support, use minimum().</div>
            <ul>
                <li class="parameter">
                  a T The first &#x60;NDArray&#x60;.
                </li>
                <li class="parameter">
                  b T The second &#x60;NDArray&#x60;. Must have the same dtype as &#x60;a&#x60;.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>maximum</h3>
            <div class="docstring">Returns the max of a and b (&#x60;a &gt; b ? a : b&#x60;) element-wise.
Supports broadcasting.</div>
            <ul>
                <li class="parameter">
                  a NDArray&lt;Rank&gt; The first ndarray.
                </li>
                <li class="parameter">
                  b NDArray&lt;Rank&gt; The second ndarray. Must have the same type as &#x60;a&#x60;.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>maximumStrict</h3>
            <div class="docstring">Returns the max of a and b (&#x60;a &gt; b ? a : b&#x60;) element-wise. Inputs must
be the same shape. For broadcasting support, use maximum().</div>
            <ul>
                <li class="parameter">
                  a T The first &#x60;NDArray&#x60;.
                </li>
                <li class="parameter">
                  b T The second &#x60;NDArray&#x60;. Must have the same dtype as &#x60;a&#x60;.
                </li>
            </ul>
          </div>
      </div>
      <div class="subheading">
        <h2>Logical</h2>
          <div class="method">
            <h3>notEqual</h3>
            <div class="docstring">Returns the truth value of (a !&#x3D; b) element-wise. Supports broadcasting.
For a stricter version without broadcasting use math.notEqualStrict().</div>
            <ul>
                <li class="parameter">
                  a NDArray&lt;Rank&gt; The first input &#x60;NDArray&#x60;.
                </li>
                <li class="parameter">
                  b NDArray&lt;Rank&gt; The second input &#x60;NDArray&#x60;. Must have the same dtype as &#x60;a&#x60;.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>notEqualStrict</h3>
            <div class="docstring"></div>
            <ul>
                <li class="parameter">
                  a T 
                </li>
                <li class="parameter">
                  b T 
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>less</h3>
            <div class="docstring">Returns the truth value of (a &lt; b) element-wise. Supports broadcasting.
For a stricter version without broadcasting use math.lessStrict().</div>
            <ul>
                <li class="parameter">
                  a NDArray&lt;Rank&gt; The first input &#x60;NDArray&#x60;.
                </li>
                <li class="parameter">
                  b NDArray&lt;Rank&gt; The second input &#x60;NDArray&#x60;. Must have the same dtype as &#x60;a&#x60;.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>lessStrict</h3>
            <div class="docstring"></div>
            <ul>
                <li class="parameter">
                  a T 
                </li>
                <li class="parameter">
                  b T 
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>equal</h3>
            <div class="docstring">Returns the truth value of (a &#x3D;&#x3D; b) element-wise. Supports broadcasting.
For a stricter version without broadcasting use math.equalStrict().</div>
            <ul>
                <li class="parameter">
                  a NDArray&lt;Rank&gt; The first input &#x60;NDArray&#x60;.
                </li>
                <li class="parameter">
                  b NDArray&lt;Rank&gt; The second input &#x60;NDArray&#x60;. Must have the same dtype as &#x60;a&#x60;.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>equalStrict</h3>
            <div class="docstring"></div>
            <ul>
                <li class="parameter">
                  a T 
                </li>
                <li class="parameter">
                  b T 
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>lessEqual</h3>
            <div class="docstring">Returns the truth value of (a &lt;&#x3D; b) element-wise. Supports broadcasting.
For a stricter version without broadcasting use math.lessEqualStrict().</div>
            <ul>
                <li class="parameter">
                  a NDArray&lt;Rank&gt; The first input &#x60;NDArray&#x60;.
                </li>
                <li class="parameter">
                  b NDArray&lt;Rank&gt; The second input &#x60;NDArray&#x60;. Must have the same dtype as &#x60;a&#x60;.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>lessEqualStrict</h3>
            <div class="docstring"></div>
            <ul>
                <li class="parameter">
                  a T 
                </li>
                <li class="parameter">
                  b T 
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>greater</h3>
            <div class="docstring">Returns the truth value of (a &gt; b) element-wise. Supports broadcasting.
For a stricter version without broadcasting use math.greaterStrict().</div>
            <ul>
                <li class="parameter">
                  a NDArray&lt;Rank&gt; The first input &#x60;NDArray&#x60;.
                </li>
                <li class="parameter">
                  b NDArray&lt;Rank&gt; The second input &#x60;NDArray&#x60;. Must have the same dtype as &#x60;a&#x60;.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>greaterStrict</h3>
            <div class="docstring"></div>
            <ul>
                <li class="parameter">
                  a T 
                </li>
                <li class="parameter">
                  b T 
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>greaterEqual</h3>
            <div class="docstring">Returns the truth value of (a &gt;&#x3D; b) element-wise. Supports broadcasting.
For a stricter version without broadcasting use math.greaterEqualStrict().</div>
            <ul>
                <li class="parameter">
                  a NDArray&lt;Rank&gt; The first input &#x60;NDArray&#x60;.
                </li>
                <li class="parameter">
                  b NDArray&lt;Rank&gt; The second input &#x60;NDArray&#x60;. Must have the same dtype as &#x60;a&#x60;.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>greaterEqualStrict</h3>
            <div class="docstring"></div>
            <ul>
                <li class="parameter">
                  a T 
                </li>
                <li class="parameter">
                  b T 
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>logicalAnd</h3>
            <div class="docstring">Returns the truth value of a AND b element-wise. Supports broadcasting.</div>
            <ul>
                <li class="parameter">
                  a NDArray&lt;Rank&gt; The first input &#x60;NDArray&#x60;.
                </li>
                <li class="parameter">
                  b NDArray&lt;Rank&gt; The second input &#x60;NDArray&#x60;.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>logicalOr</h3>
            <div class="docstring">Returns the truth value of a OR b element-wise. Supports broadcasting.</div>
            <ul>
                <li class="parameter">
                  a NDArray&lt;Rank&gt; The first input &#x60;NDArray&#x60;.
                </li>
                <li class="parameter">
                  b NDArray&lt;Rank&gt; The second input &#x60;NDArray&#x60;.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>where</h3>
            <div class="docstring">Returns the elements, either &#x60;a&#x60; or &#x60;b&#x60; depending on the &#x60;condition&#x60;.</div>
            <ul>
                <li class="parameter">
                  condition NDArray&lt;Rank&gt; The input as &#x60;NDAray&lt;&#39;bool&#39;&gt;.
                </li>
                <li class="parameter">
                  a T Input as &#x60;NDArray&#x60; which may have the same shape as
&#x60;condition&#x60;. If &#x60;condition&#x60; is rank 1, &#x60;a&#x60; may have a higher rank but
its first dimension must match the size of &#x60;condition&#x60;.
                </li>
                <li class="parameter">
                  b T Input as &#x60;NDArray&#x60; with the same shape and type as &#x60;a&#x60;.
                </li>
            </ul>
          </div>
      </div>
      <div class="subheading">
        <h2>Convolution</h2>
          <div class="method">
            <h3>conv1d</h3>
            <div class="docstring">Computes a 1D convolution over the input x.</div>
            <ul>
                <li class="parameter">
                  input T The input ndarray, of rank 3 or rank 2, of shape
&#x60;[batch, width, inChannels]&#x60;. If rank 2, batch of 1 is assumed.
                </li>
                <li class="parameter">
                  filter Array3D The filter, rank 3, of shape
[filterWidth, inDepth, outDepth].
                </li>
                <li class="parameter">
                  bias Array1D Optional bias, rank 1 of shape [outDepth].
                </li>
                <li class="parameter">
                  stride number The number of entries by which the filter is moved right at
each step.
                </li>
                <li class="parameter">
                  pad number | &quot;valid&quot; | &quot;same&quot; A string from: &#39;same&#39;, &#39;valid&#39;. The type of padding algorithm.
- &#39;same&#39; pad and stride 1: output will be of same size as input,
regardless of filter size.
- &#39;valid&#39; pad: output will be smaller than input if filter is larger
than 1x1.
- For more info, see this guide:
https:&#x2F;&#x2F;www.tensorflow.org&#x2F;api_guides&#x2F;python&#x2F;nn#Convolution
                </li>
                <li class="parameter">
                  dimRoundingMode &quot;floor&quot; | &quot;round&quot; | &quot;ceil&quot; A string from: &#39;ceil&#39;, &#39;round&#39;, &#39;floor&#39;. The
rounding mode used when computing output dimensions if pad is a
number. If none is provided, it will not round and error if the output
is of fractional size.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>conv2d</h3>
            <div class="docstring">Computes a 2D convolution over the input x.</div>
            <ul>
                <li class="parameter">
                  x T The input ndarray, of rank 4 or rank 3, of shape
&#x60;[batch, height, width, inChannels]&#x60;. If rank 3, batch of 1 is
assumed.
                </li>
                <li class="parameter">
                  filter Array4D The filter, rank 4, of shape
[filterHeight, filterWidth, inDepth, outDepth].
                </li>
                <li class="parameter">
                  bias Array1D Optional bias, rank 1 of shape [outDepth].
                </li>
                <li class="parameter">
                  strides number | [number, number] The strides of the convolution: [strideHeight,
strideWidth].
                </li>
                <li class="parameter">
                  pad number | &quot;valid&quot; | &quot;same&quot; A string from: &#39;same&#39;, &#39;valid&#39;. The type of padding algorithm.
- &#39;same&#39; pad and stride 1: output will be of same size as input,
regardless of filter size.
- &#39;valid&#39; pad: output will be smaller than input if filter is larger
than 1x1.
- For more info, see this guide:
https:&#x2F;&#x2F;www.tensorflow.org&#x2F;api_guides&#x2F;python&#x2F;nn#Convolution
                </li>
                <li class="parameter">
                  dimRoundingMode &quot;floor&quot; | &quot;round&quot; | &quot;ceil&quot; A string from: &#39;ceil&#39;, &#39;round&#39;, &#39;floor&#39;. The
rounding mode used when computing output dimensions if pad is a
number. If none is provided, it will not round and error if the output
is of fractional size.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>conv2dDerInput</h3>
            <div class="docstring">Computes the derivative of the input of a 2D convolution.</div>
            <ul>
                <li class="parameter">
                  xShape [number, number, number, number] | [number, number, number] The shape of the input: [batch, height, width, inDepth].
If length of 3, batch of 1 is assumed.
                </li>
                <li class="parameter">
                  dy T The derivative of the output, of rank 4 or rank 3 of shape
[batch, outHeight, outWidth, outDepth]. If rank 3, batch of 1 is
assumed.
                </li>
                <li class="parameter">
                  filter Array4D The filter, rank 4, of shape
[filterHeight, filterWidth, inDepth, outDepth].
                </li>
                <li class="parameter">
                  strides number | [number, number] The strides of the convolution: [strideHeight,
strideWidth].
                </li>
                <li class="parameter">
                  pad number | &quot;valid&quot; | &quot;same&quot; A string from: &#39;same&#39;, &#39;valid&#39;. The type of padding algorithm
used in the forward prop of the op.
                </li>
                <li class="parameter">
                  dimRoundingMode &quot;floor&quot; | &quot;round&quot; | &quot;ceil&quot; A string from: &#39;ceil&#39;, &#39;round&#39;, &#39;floor&#39;. The
rounding mode used when computing output dimensions if pad is a
number. If none is provided, it will not round and error if the output
is of fractional size.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>conv2dTranspose</h3>
            <div class="docstring">Computes the transposed 2D convolution of an image, also known as a
deconvolution.</div>
            <ul>
                <li class="parameter">
                  x T The input image, of rank 4 or rank 3, of shape
[batch, height, width, inDepth]. If rank 3, batch of 1 is assumed.
                </li>
                <li class="parameter">
                  filter Array4D The filter, rank 4, of shape
&#x60;[filterHeight, filterWidth, outDepth, inDepth]&#x60;.
&#x60;inDepth&#x60; must match &#x60;inDepth&#x60; in &#x60;x&#x60;.
                </li>
                <li class="parameter">
                  outputShape [number, number, number, number] | [number, number, number] Output shape, of rank 4 or rank 3:
[batch, height, width, outDepth]. If rank 3, batch of 1 is assumed.
                </li>
                <li class="parameter">
                  strides number | [number, number] The strides of the original convolution:
&#x60;[strideHeight, strideWidth]&#x60;.
                </li>
                <li class="parameter">
                  pad number | &quot;valid&quot; | &quot;same&quot; A string from: &#39;same&#39;, &#39;valid&#39;. The type of padding algorithm
used in the non-transpose version of the op.
                </li>
                <li class="parameter">
                  dimRoundingMode &quot;floor&quot; | &quot;round&quot; | &quot;ceil&quot; A string from: &#39;ceil&#39;, &#39;round&#39;, &#39;floor&#39;. The
rounding mode used when computing output dimensions if pad is a
number. If none is provided, it will not round and error if the output
is of fractional size.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>depthwiseConv2D</h3>
            <div class="docstring">Depthwise 2D convolution.

Given a 4D &#x60;input&#x60; array and a &#x60;filter&#x60; array of shape
&#x60;[filterHeight, filterWidth, inChannels, channelMultiplier]&#x60; containing
&#x60;inChannels&#x60; convolutional filters of depth 1, this op applies a
different filter to each input channel (expanding from 1 channel to
&#x60;channelMultiplier&#x60; channels for each), then concatenates the results
together. The output has &#x60;inChannels * channelMultiplier&#x60; channels.

See https:&#x2F;&#x2F;www.tensorflow.org&#x2F;api_docs&#x2F;python&#x2F;tf&#x2F;nn&#x2F;depthwise_conv2d for
more details.</div>
            <ul>
                <li class="parameter">
                  input T The input ndarray, of rank 4 or rank 3, of shape
&#x60;[batch, height, width, inChannels]&#x60;. If rank 3, batch of 1 is
assumed.
                </li>
                <li class="parameter">
                  filter Array4D The filter ndarray, rank 4, of shape
&#x60;[filterHeight, filterWidth, inChannels, channelMultiplier]&#x60;.
                </li>
                <li class="parameter">
                  strides number | [number, number] The strides of the convolution: [strideHeight,
strideWidth]. If strides is a single number, then &#x60;strideHeight &#x3D;&#x3D;
strideWidth&#x60;.
                </li>
                <li class="parameter">
                  pad number | &quot;valid&quot; | &quot;same&quot; A string from: &#39;same&#39;, &#39;valid&#39;. The type of padding algorithm.
- &#39;same&#39; pad and stride 1: output will be of same size as input,
regardless of filter size.
- &#39;valid&#39; pad: output will be smaller than input if filter is larger
than 1x1.
- For more info, see this guide:
https:&#x2F;&#x2F;www.tensorflow.org&#x2F;api_guides&#x2F;python&#x2F;nn#Convolution
                </li>
                <li class="parameter">
                  rates number | [number, number] The dilation rates: &#x60;[rateHeight, rateWidth]&#x60; in which we
sample input values across the height and width dimensions in atrous
convolution. Defaults to &#x60;[1, 1]&#x60;. If &#x60;rate&#x60; is a single number, then
&#x60;rateHeight &#x3D;&#x3D; rateWidth&#x60;. If it is greater than 1, then all values
of &#x60;strides&#x60; must be 1.
                </li>
                <li class="parameter">
                  dimRoundingMode &quot;floor&quot; | &quot;round&quot; | &quot;ceil&quot; A string from: &#39;ceil&#39;, &#39;round&#39;, &#39;floor&#39;. The
rounding mode used when computing output dimensions if pad is a
number. If none is provided, it will not round and error if the output
is of fractional size.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>maxPool</h3>
            <div class="docstring">Computes the 2D max pooling of an image.</div>
            <ul>
                <li class="parameter">
                  x T The input ndarray, of rank 4 or rank 3 of shape
[batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.
                </li>
                <li class="parameter">
                  filterSize number | [number, number] The filter size, a tuple [filterHeight, filterWidth].
                </li>
                <li class="parameter">
                  strides number | [number, number] The strides of the pooling: [strideHeight, strideWidth].
                </li>
                <li class="parameter">
                  pad number | &quot;valid&quot; | &quot;same&quot; A string from: &#39;same&#39;, &#39;valid&#39;. The type of padding algorithm.
- &#39;same&#39; pad and stride 1: output will be of same size as input,
regardless of filter size.
- &#39;valid&#39; pad: output will be smaller than input if filter is larger
than 1x1.
- For more info, see this guide:
https:&#x2F;&#x2F;www.tensorflow.org&#x2F;api_guides&#x2F;python&#x2F;nn#Convolution
                </li>
                <li class="parameter">
                  dimRoundingMode &quot;floor&quot; | &quot;round&quot; | &quot;ceil&quot; A string from: &#39;ceil&#39;, &#39;round&#39;, &#39;floor&#39;. The
rounding mode used when computing output dimensions if pad is a
number. If none is provided, it will not round and error if the output
is of fractional size.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>minPool</h3>
            <div class="docstring">Computes the 2D min pooling of an image.</div>
            <ul>
                <li class="parameter">
                  input T The input ndarray, of rank 4 or rank 3 of shape
[batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.
                </li>
                <li class="parameter">
                  filterSize number | [number, number] The filter size, a tuple [filterHeight, filterWidth].
                </li>
                <li class="parameter">
                  strides number | [number, number] The strides of the pooling: [strideHeight, strideWidth].
                </li>
                <li class="parameter">
                  pad number | &quot;valid&quot; | &quot;same&quot; A string from: &#39;same&#39;, &#39;valid&#39;. The type of padding algorithm.
- &#39;same&#39; pad and stride 1: output will be of same size as input,
regardless of filter size.
- &#39;valid&#39; pad: output will be smaller than input if filter is larger
than 1x1.
- For more info, see this guide:
https:&#x2F;&#x2F;www.tensorflow.org&#x2F;api_guides&#x2F;python&#x2F;nn#Convolution
                </li>
                <li class="parameter">
                  dimRoundingMode &quot;floor&quot; | &quot;round&quot; | &quot;ceil&quot; A string from: &#39;ceil&#39;, &#39;round&#39;, &#39;floor&#39;. The
rounding mode used when computing output dimensions if pad is a
number. If none is provided, it will not round and error if the output
is of fractional size.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>avgPool</h3>
            <div class="docstring">Computes the 2D average pooling of an image.</div>
            <ul>
                <li class="parameter">
                  x T The input ndarray, of rank 4 or rank 3 of shape
[batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.
                </li>
                <li class="parameter">
                  filterSize number | [number, number] The filter size, a tuple [filterHeight, filterWidth].
                </li>
                <li class="parameter">
                  strides number | [number, number] The strides of the pooling: [strideHeight, strideWidth].
                </li>
                <li class="parameter">
                  pad number | &quot;valid&quot; | &quot;same&quot; A string from: &#39;same&#39;, &#39;valid&#39;. The type of padding algorithm.
- &#39;same&#39; pad and stride 1: output will be of same size as input,
regardless of filter size.
- &#39;valid&#39; pad: output will be smaller than input if filter is larger
than 1x1.
- For more info, see this guide:
https:&#x2F;&#x2F;www.tensorflow.org&#x2F;api_guides&#x2F;python&#x2F;nn#Convolution
                </li>
                <li class="parameter">
                  dimRoundingMode &quot;floor&quot; | &quot;round&quot; | &quot;ceil&quot; A string from: &#39;ceil&#39;, &#39;round&#39;, &#39;floor&#39;. The
rounding mode used when computing output dimensions if pad is a
number. If none is provided, it will not round and error if the output
is of fractional size.
                </li>
            </ul>
          </div>
      </div>
      <div class="subheading">
        <h2>Images</h2>
          <div class="method">
            <h3>resizeBilinear</h3>
            <div class="docstring">Bilinear resize a batch of 3D images to a new shape.</div>
            <ul>
                <li class="parameter">
                  images T The images, of rank 4 or rank 3, of shape
&#x60;[batch, height, width, inChannels]&#x60;. If rank 3, batch of 1 is assumed.
                </li>
                <li class="parameter">
                  size [number, number] The new shape &#x60;[newHeight, newWidth]&#x60; to resize the
images to. Each channel is resized individually.
                </li>
                <li class="parameter">
                  alignCorners boolean An optional bool. Defaults to False. If true, rescale
input by (new_height - 1) &#x2F; (height - 1), which exactly aligns the 4
corners of images and resized images. If false, rescale by
new_height&#x2F;height. Treat similarly the width dimension.
                </li>
            </ul>
          </div>
      </div>
      <div class="subheading">
        <h2>RNN</h2>
          <div class="method">
            <h3>multiRNNCell</h3>
            <div class="docstring">Computes the next states and outputs of a stack of LSTMCells.
Each cell output is used as input to the next cell.
This is only the forward mode.
Derived from tf.contrib.rn.MultiRNNCell.</div>
            <ul>
                <li class="parameter">
                  lstmCells {} Array of LSTMCell functions.
                </li>
                <li class="parameter">
                  data Array2D The input to the cell.
                </li>
                <li class="parameter">
                  c {} Array of previous cell states.
                </li>
                <li class="parameter">
                  h {} Array of previous cell outputs.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>basicLSTMCell</h3>
            <div class="docstring">Computes the next state and output of a BasicLSTMCell.
This is only the forward mode.
Derived from tf.contrib.rnn.BasicLSTMCell.</div>
            <ul>
                <li class="parameter">
                  forgetBias Scalar Forget bias for the cell.
                </li>
                <li class="parameter">
                  lstmKernel Array2D The weights for the cell.
                </li>
                <li class="parameter">
                  lstmBias Array1D The bias for the cell.
                </li>
                <li class="parameter">
                  data Array2D The input to the cell.
                </li>
                <li class="parameter">
                  c Array2D Previous cell state.
                </li>
                <li class="parameter">
                  h Array2D Previous cell output.
                </li>
            </ul>
          </div>
      </div>
      <div class="subheading">
        <h2>Matrices</h2>
          <div class="method">
            <h3>matMul</h3>
            <div class="docstring">Computes the dot product of two matrices, A * B. These must be matrices,
use matrixTimesVector and vectorTimesMatrix, dotProduct, and outerProduct
in other cases.</div>
            <ul>
                <li class="parameter">
                  a Array2D First matrix in dot product operation.
                </li>
                <li class="parameter">
                  b Array2D Second matrix in dot product operation.
                </li>
                <li class="parameter">
                  aOrientation MatrixOrientation The MatrixOrientation of A. If using TRANSPOSED, will
compute A^T * B.
                </li>
                <li class="parameter">
                  bOrientation MatrixOrientation The MatrixOrientation of B. If using TRANSPOSED, will
compute A * B^T.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>vectorTimesMatrix</h3>
            <div class="docstring">Computes the dot product of a vector and a matrix, v * B.</div>
            <ul>
                <li class="parameter">
                  v Array1D The vector in dot product operation.
                </li>
                <li class="parameter">
                  matrix Array2D The matrix in dot product operation.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>matrixTimesVector</h3>
            <div class="docstring">Computes the dot product of a matrix and vector, A * v.</div>
            <ul>
                <li class="parameter">
                  matrix Array2D The matrix in dot product operation.
                </li>
                <li class="parameter">
                  v Array1D The vector in dot product operation.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>dotProduct</h3>
            <div class="docstring">Computes the dot product of two vectors, v1 * v2.</div>
            <ul>
                <li class="parameter">
                  v1 Array1D The first vector in the dot product operation.
                </li>
                <li class="parameter">
                  v2 Array1D The second vector in the dot product operation.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>outerProduct</h3>
            <div class="docstring">Computes the outer product of two vectors, v1 and v2.</div>
            <ul>
                <li class="parameter">
                  v1 Array1D The first vector in the outer product operation.
                </li>
                <li class="parameter">
                  v2 Array1D The second vector in the dot product operation.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>norm</h3>
            <div class="docstring">Computes the norm of scalar, vectors, and matrices.
This function can compute several different vector norms (the 1-norm, the
Euclidean or 2-norm, the inf-norm, and in general the p-norm for p &gt; 0)
and matrix norms (Frobenius, 1-norm, and inf-norm).</div>
            <ul>
                <li class="parameter">
                  x NDArray&lt;Rank&gt; The input array.
                </li>
                <li class="parameter">
                  ord number | &quot;euclidean&quot; | &quot;fro&quot; Optional. Order of the norm. Supported norm types are
following: ord         norm for matrices          norm for vectors
-------------------------------------------------------
&#39;euclidean&#39; Frobenius norm             2-norm
fro       Frobenius norm	            
Infinity    max(sum(abs(x), axis&#x3D;1))   max(abs(x))
-Infinity   min(sum(abs(x), axis&#x3D;1))   min(abs(x))
1           max(sum(abs(x), axis&#x3D;0))   sum(abs(x))
2           -                          sum(abs(x)^2)^1&#x2F;2*
                </li>
                <li class="parameter">
                  axis number | {} Optional. If axis is null (the default), the input is
considered a vector and a single vector norm is computed over the entire
set of values in the NDArray, i.e. norm(x, ord) is equivalent
to norm(x.reshape([-1]), ord). If axis is a integer, the input
is considered a batch of vectors, and axis determines the axis in x
over which to compute vector norms. If axis is a 2-tuple of integer it is
considered a batch of matrices and axis determines the axes in NDArray
over which to compute a matrix norm.
                </li>
                <li class="parameter">
                  keepDims boolean Optional. If true, the norm have the same dimensionality
as the input.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>transpose</h3>
            <div class="docstring">Transposes the array. Permutes the dimensions according to &#x60;perm&#x60;.

The returned array&#39;s dimension &#x60;i&#x60; will correspond to the input dimension
&#x60;perm[i]&#x60;. If &#x60;perm&#x60; is not given, it is set to &#x60;[n-1...0]&#x60;, where &#x60;n&#x60; is
the rank of the input array. Hence by default, this operation performs a
regular matrix transpose on 2-D input arrays.</div>
            <ul>
                <li class="parameter">
                  x NDArray&lt;R&gt; The array to transpose.
                </li>
                <li class="parameter">
                  perm {} Optional. The permutation of the dimensions of a.
                </li>
            </ul>
          </div>
      </div>
      <div class="subheading">
        <h2>Reduction</h2>
          <div class="method">
            <h3>logSumExp</h3>
            <div class="docstring">Computes the log(sum(exp(elements across the reduction dimensions)).

Reduces the input along the dimensions given in &#x60;axis&#x60;. Unless &#x60;keepDims&#x60;
is true, the rank of the array is reduced by 1 for each entry in &#x60;axis&#x60;.
If &#x60;keepDims&#x60; is true, the reduced dimensions are retained with length 1.
If &#x60;axis&#x60; has no entries, all dimensions are reduced, and an array with a
single element is returned.</div>
            <ul>
                <li class="parameter">
                  input NDArray&lt;Rank&gt; The input NDArray.
                </li>
                <li class="parameter">
                  axis number | {} Optional. The dimension(s) to reduce. If null (the default),
reduces all dimensions.
                </li>
                <li class="parameter">
                  keepDims boolean Optional. If true, retains reduced dimensions with length
of 1. Defaults to false.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>sum</h3>
            <div class="docstring">Computes the sum of elements across dimensions of an array.

Reduces the input along the dimensions given in &#x60;axes&#x60;. Unless &#x60;keepDims&#x60;
is true, the rank of the array is reduced by 1 for each entry in &#x60;axes&#x60;.
If &#x60;keepDims&#x60; is true, the reduced dimensions are retained with length 1.
If axes has no entries, all dimensions are reduced, and an array with a
single element is returned.</div>
            <ul>
                <li class="parameter">
                  x NDArray&lt;Rank&gt; The input array to compute the sum over.
                </li>
                <li class="parameter">
                  axis number | {} Optional. The dimension(s) to reduce. By default it reduces
all dimensions.
                </li>
                <li class="parameter">
                  keepDims boolean Optional. If true, retains reduced dimensions with size 1.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>mean</h3>
            <div class="docstring">Computes the mean of elements across dimensions of an array.

Reduces &#x60;x&#x60; along the dimensions given in &#x60;axis&#x60;. Unless &#x60;keepDims&#x60; is
true, the rank of the array is reduced by 1 for each entry in &#x60;axis&#x60;.
If &#x60;keepDims&#x60; is true, the reduced dimensions are retained with length 1.
If &#x60;axis&#x60; has no entries, all dimensions are reduced, and an array with a
single element is returned.</div>
            <ul>
                <li class="parameter">
                  x NDArray&lt;Rank&gt; The input array.
                </li>
                <li class="parameter">
                  axis number | {} Optional. The dimension(s) to reduce. By default it reduces
all dimensions.
                </li>
                <li class="parameter">
                  keepDims boolean Optional. If true, retains reduced dimensions with size 1.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>min</h3>
            <div class="docstring">Computes the minimum value from the input.

Reduces the input along the dimensions given in &#x60;axes&#x60;. Unless &#x60;keepDims&#x60;
is true, the rank of the array is reduced by 1 for each entry in &#x60;axes&#x60;.
If &#x60;keepDims&#x60; is true, the reduced dimensions are retained with length 1.
If &#x60;axes&#x60; has no entries, all dimensions are reduced, and an array with a
single element is returned.</div>
            <ul>
                <li class="parameter">
                  x NDArray&lt;Rank&gt; The input NDArray.
                </li>
                <li class="parameter">
                  axis number | {} Optional. The dimension(s) to reduce. By default it reduces
all dimensions.
                </li>
                <li class="parameter">
                  keepDims boolean Optional. If true, retains reduced dimensions with size 1.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>max</h3>
            <div class="docstring">Computes the maximum of elements across dimensions of an array.

Reduces the input along the dimensions given in &#x60;axes&#x60;. Unless &#x60;keepDims&#x60;
is true, the rank of the array is reduced by 1 for each entry in &#x60;axes&#x60;.
If &#x60;keepDims&#x60; is true, the reduced dimensions are retained with length 1.
If &#x60;axes&#x60; has no entries, all dimensions are reduced, and an array with a
single element is returned.</div>
            <ul>
                <li class="parameter">
                  x NDArray&lt;Rank&gt; The input array.
                </li>
                <li class="parameter">
                  axis number | {} Optional. The dimension(s) to reduce. By default it reduces
all dimensions.
                </li>
                <li class="parameter">
                  keepDims boolean Optional. If true, retains reduced dimensions with size 1.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>argMin</h3>
            <div class="docstring">Returns the indices of the minimum values along an &#x60;axis&#x60;. The result has
the same shape as &#x60;input&#x60; with the dimension along &#x60;axis&#x60; removed.</div>
            <ul>
                <li class="parameter">
                  x NDArray&lt;Rank&gt; The input array.
                </li>
                <li class="parameter">
                  axis number Optional. The dimension to reduce. By default it reduces
across all axes and returns the flat index.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>argMax</h3>
            <div class="docstring">Returns the indices of the maximum values along an &#x60;axis&#x60;. The result has
the same shape as &#x60;input&#x60; with the dimension along &#x60;axis&#x60; removed.</div>
            <ul>
                <li class="parameter">
                  x NDArray&lt;Rank&gt; The input array.
                </li>
                <li class="parameter">
                  axis number Optional. The dimension to reduce. By default it reduces
across all axes and returns the flat index
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>argMaxEquals</h3>
            <div class="docstring">Returns a 1 if the argMax of x1 and x2 are the same, otherwise 0.</div>
            <ul>
                <li class="parameter">
                  x1 NDArray&lt;Rank&gt; The first input NDArray.
                </li>
                <li class="parameter">
                  x2 NDArray&lt;Rank&gt; The second input NDArray.
                </li>
            </ul>
          </div>
      </div>
      <div class="subheading">
        <h2>Classification</h2>
          <div class="method">
            <h3>softmaxCrossEntropy</h3>
            <div class="docstring">Computes softmax cross entropy between logits and labels.

Measures the probability error in discrete classification tasks in which
the classes are mutually exclusive (each entry is in exactly one class).
For example, each CIFAR-10 image is labeled with one and only one label: an
image can be a dog or a truck, but not both.

NOTE: While the classes are mutually exclusive, their probabilities need
not be. All that is required is that each row of labels is a valid
probability distribution. If they are not, the computation of the gradient
will be incorrect.

WARNING: This op expects unscaled logits, since it performs a softmax on
logits internally for efficiency. Do not call this op with the output of
softmax, as it will produce incorrect results.

logits and labels must have the same shape, e.g. [batch_size, num_classes]
and the same dtype.</div>
            <ul>
                <li class="parameter">
                  labels T The labels array.
                </li>
                <li class="parameter">
                  logits T The logits array.
                </li>
                <li class="parameter">
                  dim number The dimension softmax would be performed on. Defaults to -1
which indicates the last dimension.
                </li>
            </ul>
          </div>
      </div>
      <div class="subheading">
        <h2>Basic math</h2>
          <div class="method">
            <h3>neg</h3>
            <div class="docstring">Computes -1 * A element-wise.</div>
            <ul>
                <li class="parameter">
                  x T The input array.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>ceil</h3>
            <div class="docstring">Computes ceiling of input NDArray element-wise. y &#x3D; ceil(x)
TODO(nsthorat): Make this return an int32 when we add rank as a
generic.</div>
            <ul>
                <li class="parameter">
                  x T The input NDArray.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>floor</h3>
            <div class="docstring">Computes floor of input NDArray element-wise. y &#x3D; floor(x).</div>
            <ul>
                <li class="parameter">
                  x T The input NDArray.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>exp</h3>
            <div class="docstring">Computes exponential of the input NDArray element-wise. y &#x3D; e ^ x</div>
            <ul>
                <li class="parameter">
                  x T The input NDArray.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>log</h3>
            <div class="docstring">Computes natural logarithm of the input NDArray element-wise. y &#x3D; ln(x)</div>
            <ul>
                <li class="parameter">
                  x T The input NDArray.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>sqrt</h3>
            <div class="docstring">Computes square root of the input NDArray element-wise. y &#x3D; sqrt(x)</div>
            <ul>
                <li class="parameter">
                  x T The input NDArray.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>square</h3>
            <div class="docstring">Computes square of &#x60;x&#x60; element-wise.</div>
            <ul>
                <li class="parameter">
                  x T The input array.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>abs</h3>
            <div class="docstring">Computes absolute value element-wise.</div>
            <ul>
                <li class="parameter">
                  x T The input NDArray.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>clip</h3>
            <div class="docstring">Clips values element-wise.</div>
            <ul>
                <li class="parameter">
                  x T The input NDArray.
                </li>
                <li class="parameter">
                  min number Lower-bound of range to be clipped to.
                </li>
                <li class="parameter">
                  max number Upper-bound of range to be clipped to.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>relu</h3>
            <div class="docstring">Computes rectified linear element-wise, max(x, 0).</div>
            <ul>
                <li class="parameter">
                  x T The input NDArray.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>elu</h3>
            <div class="docstring">Computes exponential linear element-wise</div>
            <ul>
                <li class="parameter">
                  x T the input NDArray
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>selu</h3>
            <div class="docstring">Computes scaled exponential linear element-wise.</div>
            <ul>
                <li class="parameter">
                  x T 
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>leakyRelu</h3>
            <div class="docstring">Computes leaky rectified linear element-wise</div>
            <ul>
                <li class="parameter">
                  x T the input NDArray
                </li>
                <li class="parameter">
                  alpha number scaling factor for negative values, defaults to 0.2
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>prelu</h3>
            <div class="docstring">Computes leaky rectified linear element-wise with parametric alphas</div>
            <ul>
                <li class="parameter">
                  x T the input NDArray
                </li>
                <li class="parameter">
                  alpha T scaling factor NDArray for negative values
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>sigmoid</h3>
            <div class="docstring">Computes sigmoid element-wise, y &#x3D; 1 &#x2F; (1 + exp(-x)).</div>
            <ul>
                <li class="parameter">
                  x T The input NDArray.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>sin</h3>
            <div class="docstring">Computes sin of the input NDArray element-wise, y &#x3D; sin(x).</div>
            <ul>
                <li class="parameter">
                  x T The input NDArray.

TODO(smilkov): Fix dl.cos() and other ops that should return a float.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>cos</h3>
            <div class="docstring">Computes cos of the input NDArray element-wise, y &#x3D; cos(x).</div>
            <ul>
                <li class="parameter">
                  x T The input NDArray.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>tan</h3>
            <div class="docstring">Computes tan of the input NDArray element-wise, y &#x3D; tan(x).</div>
            <ul>
                <li class="parameter">
                  x T The input NDArray.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>asin</h3>
            <div class="docstring">Computes asin of the input NDArray element-wise, y &#x3D; asin(x).</div>
            <ul>
                <li class="parameter">
                  x T The input NDArray.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>acos</h3>
            <div class="docstring">Computes acos of the input NDArray element-wise, y &#x3D; acos(x).</div>
            <ul>
                <li class="parameter">
                  x T The input NDArray.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>atan</h3>
            <div class="docstring">Computes atan of the input NDArray element-wise, y &#x3D; atan(x).</div>
            <ul>
                <li class="parameter">
                  x T The input NDArray.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>sinh</h3>
            <div class="docstring">Computes hyperbolic sin of the input NDArray element-wise, y &#x3D; sinh(x).</div>
            <ul>
                <li class="parameter">
                  x T The input NDArray.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>cosh</h3>
            <div class="docstring">Computes hyperbolic cos of the input NDArray element-wise, y &#x3D; cosh(x).</div>
            <ul>
                <li class="parameter">
                  x T The input NDArray.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>tanh</h3>
            <div class="docstring">Computes hyperbolic tangent of the input NDArray element-wise.</div>
            <ul>
                <li class="parameter">
                  x T The input NDArray.
                </li>
            </ul>
          </div>
          <div class="method">
            <h3>step</h3>
            <div class="docstring">Computes step of the input NDArray element-wise,
y&#x3D;1 if x&gt;0|alpha*x if x&lt;&#x3D;0.</div>
            <ul>
                <li class="parameter">
                  x T The input NDArray.
                </li>
                <li class="parameter">
                  alpha number The gradient when input is negative.
                </li>
            </ul>
          </div>
      </div>
  </div>
